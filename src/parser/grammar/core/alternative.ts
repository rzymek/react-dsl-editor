import { error, GrammarNode, isParserError, ParserError } from '../../types';export function alternative<T extends string>(...seq: GrammarNode<T>[]) {  const grammar: GrammarNode<T> = {    type: 'alternative' as T,    children: seq,    parse(text, context) {      const errors: ParserError<T>[] = [];      if (!context.faultTolerant) {        for (const gn of seq) {          const result = gn.parse(text, context);          if (isParserError(result)) {            errors.push(result);            continue;          }          return result;        }      } else {        for (const gn of seq) {          const result = gn.parse(text, {            ...context,            faultTolerant: false,          });          if (isParserError(result)) {            errors.push(result);            continue;          }          return result;        }      }      return error({        got: text,        expected: errors.flatMap(it => it.expected),        grammar,      });    },    suggestions() {      return seq.flatMap(it => it.suggestions());    },  };  return grammar;}