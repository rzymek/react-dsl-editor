import {filter, pipe, sortBy, last, isEmpty, firstBy} from 'remeda';import {error, GrammarNode, isParserError, isParserSuccess, ParserError, ParserSuccess} from '../../types';export function alternative<T extends string>(...seq: GrammarNode<T>[]) {  const grammar: GrammarNode<T> = {    type: 'alternative' as T,    children: seq,    parse(text, _context) {      const context = {        ..._context,        depth: _context.depth + 1,      }      // const errors: ParserError<T>[] = [];      // const faultToleranceMode = context.faultToleranceMode(grammar, context);      // if (isEmpty(faultToleranceMode)) {      //   for (const gn of seq) {      //     const result = gn.parse(text, context);      //     if (isParserError(result)) {      //       errors.push(result);      //       continue;      //     }      //     return result;      //   }      // } else {      const results = seq.map(gn => gn.parse(text, context));      const longestFaultTolerantResult = pipe(        results,        filter(isParserSuccess),        firstBy(it => it.recoverableError ? Infinity : 0, it => -it.text.length),      );      if (longestFaultTolerantResult) {        return longestFaultTolerantResult;      }      // }      return error({        got: text,        expected: results.flatMap(it=>isParserError(it) ? it.expected : []),        grammar,      });    },    suggestions() {      return seq.flatMap(it => it.suggestions());    },  };  return grammar;}