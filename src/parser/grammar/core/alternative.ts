import { filter, pipe, sortBy, last } from 'remeda';import { error, GrammarNode, isParserError, isParserSuccess, ParserError, ParserSuccess } from '../../types';export function alternative<T extends string>(...seq: GrammarNode<T>[]) {  const grammar: GrammarNode<T> = {    type: 'alternative' as T,    children: seq,    parse(text, context) {      const errors: ParserError<T>[] = [];      if (!context.faultTolerant) {        for (const gn of seq) {          const result = gn.parse(text, context);          if (isParserError(result)) {            errors.push(result);            continue;          }          return result;        }      } else {        for (const gn of seq) {          const result = gn.parse(text, {            ...context,            faultTolerant: false          });          if (isParserSuccess(result)) {            return result;          }        }        const results = seq.map(gn => gn.parse(text, {          ...context,          faultTolerant: true,        }))        const longestFaultTolerantResult =  pipe(          results,          filter(isParserSuccess),          sortBy((it:ParserSuccess<string>) => it.text.length),          last()        )        if(longestFaultTolerantResult) {          return {            ...longestFaultTolerantResult,            recoverableError: true,          };        }      }      return error({        got: text,        expected: errors.flatMap(it => it.expected),        grammar,      });    },    suggestions() {      return seq.flatMap(it => it.suggestions());    },  };  return grammar;}