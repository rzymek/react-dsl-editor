import {error, GrammarNode, isParserError, ParserContext, ParserError} from '../../types';export function alternative<T extends string>(...seq: GrammarNode<T>[]) {  const grammar: GrammarNode<T> = {    type: 'alternative' as T,    children: seq,    parse(text, _context) {      const context: ParserContext<T> = {        ..._context,        path: [..._context.path, grammar],      };      const errors: ParserError<T>[] = [];      for (const gn of seq) {        const result = gn.parse(text, context);        if (isParserError(result)) {          errors.push(result);          continue;        }        return result;      }      return error({        offset: 0,        path: context.path,        grammar,        got: text,        expected: errors.flatMap(it => it.expected)      });    },    suggestions() {      return seq.flatMap(it => it.suggestions());    },  };  return grammar;}