import {filter, firstBy, pipe} from 'remeda';import {error, GrammarNode, isParserError, isParserSuccess} from '../../types';export function alternative<T extends string>(...seq: GrammarNode<T>[]) {  const grammar: GrammarNode<T> = {    type: 'alternative' as T,    children: seq,    parse(text, _context) {      const context = {        ..._context,        depth: _context.depth + 1,      }      const results = seq.map(gn => gn.parse(text, context));      const longestFaultTolerantResult = pipe(        results,        filter(isParserSuccess),        firstBy(it => it.recoverableError ? Infinity : 0, it => -it.text.length),      );      if (longestFaultTolerantResult) {        return longestFaultTolerantResult;      }      // }      return error({        got: text,        expected: results.flatMap(it=>isParserError(it) ? it.expected : []),        grammar,        offset: Math.min(...results.map(it => isParserError(it) ? it.offset : 0))      });    },    suggestions() {      return seq.flatMap(it => it.suggestions());    },  };  return grammar;}