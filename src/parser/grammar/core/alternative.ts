import {firstBy, isEmpty, pipe} from "remeda";import {error, GrammarNode, isParserError, ParserContext, ParserError, ParserSuccess, success} from '../../types';export function alternative<T extends string>(...seq: GrammarNode<T>[]) {  const grammar: GrammarNode<T> = {    type: 'alternative' as T,    children: seq,    parse(text, _context) {      const context: ParserContext<T> = {        ..._context,        path: [..._context.path, grammar],      };      const errors: ParserError<T>[] = [];      const recoverableErrors: ParserSuccess<T>[] = [];      for (const gn of seq) {        const result = gn.parse(text, context);        if (isParserError(result)) {          errors.push(result);          continue;        }        if (result.errorLabel) {          recoverableErrors.push(result);          continue;        }        return success({          grammar,          children: [result],          text: result.text,          errorLabel: result.errorLabel,        });      }      if (isEmpty(recoverableErrors)) {        return error({          offset: 0,          path: context.path,          grammar,          got: text,          expected: errors.flatMap(it => it.expected)        });      } else {        const bestSuccessWithErrorLabel = pipe(recoverableErrors,          firstBy(it => -it.text.length) // success with shortest error label        )!;        return success({          grammar,          children: [bestSuccessWithErrorLabel],          text: bestSuccessWithErrorLabel.text,          errorLabel: bestSuccessWithErrorLabel.errorLabel,        })      }    },    suggestions() {      return seq.flatMap(it => it.suggestions());    },  };  return grammar;}