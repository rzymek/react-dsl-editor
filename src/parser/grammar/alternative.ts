import {  error,  GrammarNode, isParserError,  ParserContext,  ParserError,  ParserSuccess} from '../types';import {map, only, pipe, sortBy, take} from 'remeda';import {tap} from '../tap';export function alternative<T, C>(...seq: GrammarNode<T, C>[]): GrammarNode<T, C | 'alternative'> {  const grammar: GrammarNode<T, C | 'alternative'> = {    type: 'alternative',    parse: alternative,    suggestions() {      return seq.flatMap(it => it.suggestions());    }  };  function alternative(text: string, context: ParserContext<T, C>) {    tap(alternative, text);    if (!context.faultTolerant) {      const errors: ParserError<T, C>[] = [];      for (const gn of seq) {        const result = gn.parse(text, context);        if (isParserError(result)) {          errors.push(result);          continue;        }        return result;      }      return error({        got: text,      })    } else {      for (const gn of seq) {        const result = gn.parse(text, {          ...context,          faultTolerant: false,        });        if (isParserError(result)) {          continue;        }        return result;      }    }    for (const parser of seq) {      const result = parser(text);      if (isParserError(result)) {        errors.push(result);      } else {        return {          type,          parser: alternative,          text: result.text,          children: [result],        } satisfies ParserSuccess<T>;      }    }    return {      type,      offset: 0,      expected: errors.flatMap(e => `${e.expected} (${e.type})`),      got: pipe(        errors,        map(it => it.got),        sortBy([it => it.length, 'desc']),        take(1),        only(),      )!,      parser: alternative,    } satisfies ParserError<T>;  }  return grammar;}